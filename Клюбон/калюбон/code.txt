DECLARE produusing System.Collections.Generic;
using System.Drawing;
using System.IO;
using System;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using System.Linq;
using System.Text;
using static WindowsFormsApp2.Form1.LexicalAnalyzer;
using System.Diagnostics;


namespace WindowsFormsApp2
{
    public partial class Form1 : Form
    {
        private struct EditOperation
        {
            public string Type; // "Insert", "Delete", "Cut", "Undo"
            public string Text; // Текст, который был вставлен, удален или вырезан
            public int Position; // Позиция, в которой была выполнена операция
        }

        private Stack<EditOperation> undoStack = new Stack<EditOperation>();
        private Stack<EditOperation> redoStack = new Stack<EditOperation>();

        private string currentFilePath = null; // Путь к текущему файлу 
        private bool isTextChanged = true;  // Флаг, указывающий, были ли внесены изменения
        private bool fileSavedSinceLastChange = true;
        private char lastCharEntered = '\0'; // Храним последний введенный символ 
        private int i = 1;
        private string lastOperation = ""; // Строка, запоминающая последнюю операцию для повтора
        private string cuttedText = ""; // Строка для хранения вырезанного текста.

        private bool ignoreTextChanged = false;
        private int cursorPosition = 0;
        public Form1()
        {
            InitializeComponent();
            undoStack.Push(new EditOperation { Type = "Initial", Text = "", Position = 0 });
            Tool_tips();
            richTextBox1.AllowDrop = true;
            richTextBox1.DragEnter += MainForm_DragEnter;
            richTextBox1.DragDrop += MainForm_DragDrop;
            richTextBox1.TextChanged += richTextBox1_TextChanged;

            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.MainForm_FormClosing);
        }
        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {

        }

        public enum TokenType
        {
            DECLARE = 1,       // Ключевое слово
            CONSTANT = 2,      // Ключевое слово
            INTEGER = 3,       // Ключевое слово
            IDENTIFIER = 4,    // Идентификатор
            WHITESPACE = 5,    // Пробел
            ASSIGNMENT = 6,      // Оператор
            INTEGER_LITERAL = 7, // Целое число без знака
            SEMICOLON = 8,     // Разделитель (в примере нет, но пусть будет)
            INVALID = 9      // Недопустимый символ
        }


        private string GetLexemeTypeDescription(LexicalAnalyzer.TokenType type)
        {
            switch (type)
            {
                case LexicalAnalyzer.TokenType.DECLARE: return "Ключевое слово DECLARE";
                case LexicalAnalyzer.TokenType.CONSTANT: return "Ключевое слово CONSTANT";
                case LexicalAnalyzer.TokenType.INTEGER: return "Ключевое слово INTEGER";
                case LexicalAnalyzer.TokenType.IDENTIFIER: return "Идентификатор";
                case LexicalAnalyzer.TokenType.WHITESPACE: return "Пробел";
                case LexicalAnalyzer.TokenType.NEWLINE: return "Перенос строки";
                case LexicalAnalyzer.TokenType.ASSIGNMENT: return "Оператор присваивания";
                case LexicalAnalyzer.TokenType.SIGN: return "Знак";
                case LexicalAnalyzer.TokenType.INTEGER_LITERAL: return "Целое число без знака";
                case LexicalAnalyzer.TokenType.END_OPERATOR: return "Конец оператора";
                case LexicalAnalyzer.TokenType.INVALID: return "Недопустимый символ";
                default: return "Неизвестно";
            }
        }






        private void richTextBox1_TextChanged(object sender, EventArgs e)
        {
            if (ignoreTextChanged)
            {
                return;
            }

            isTextChanged = true;
            fileSavedSinceLastChange = false;
            int currentPosition = richTextBox1.SelectionStart;
            int length = richTextBox1.TextLength;

            //Вычисляем изменения в тексте и сохраняем операцию
            if (undoStack.Count > 0)
            {
                EditOperation lastOperation = undoStack.Peek();
                string lastText = (lastOperation.Type == "Initial") ? "" : GetTextBeforeOperation(lastOperation);
                int lastPosition = lastOperation.Position;

                if (length > lastText.Length) //Вставка
                {
                    string insertedText = richTextBox1.Text.Substring(lastPosition, length - lastText.Length);
                    SaveEditOperation("Insert", insertedText, lastPosition);
                }
                else if (length < lastText.Length) //Удаление
                {
                    // Удалили с конца
                    int deleteLength = lastText.Length - length;
                    int deleteStart = currentPosition;
                    if (deleteStart < 0)
                    {
                        deleteStart = 0;
                    }

                    string deletedText = lastText.Substring(deleteStart, deleteLength);  // Сохраняем удаленный текст
                    SaveEditOperation("Delete", deletedText, deleteStart);
                }

                cursorPosition = richTextBox1.SelectionStart;
            }



            isTextChanged = true;
            fileSavedSinceLastChange = false;
            isTextChanged = false; // После любого изменения, повтор невозможен.
            lastOperation = "TextChanged"; // Запоминаем, что было изменение текста
            string text = richTextBox1.Text;
            LexicalAnalyzer analyzer = new LexicalAnalyzer();
            List<LexicalAnalyzer.Token> tokens = analyzer.Scan(text);

            //Сохраняем позицию курсора
            int selectionStart = richTextBox1.SelectionStart;
            int selectionLength = richTextBox1.SelectionLength;

            //сбрасываем все форматы
            richTextBox1.SelectAll();
            richTextBox1.SelectionColor = richTextBox1.ForeColor;
            richTextBox1.SelectionFont = richTextBox1.Font; // Возвращаем исходный шрифт

            int position = 0;
            foreach (LexicalAnalyzer.Token token in tokens)
            {
                int startPosition = position;
                int endPosition = startPosition + token.Value.Length;

                if (token.Type == LexicalAnalyzer.TokenType.DECLARE ||
                    token.Type == LexicalAnalyzer.TokenType.CONSTANT ||
                    token.Type == LexicalAnalyzer.TokenType.INTEGER)
                {
                    if (startPosition >= 0 && startPosition + token.Value.Length <= richTextBox1.TextLength)
                    {
                        richTextBox1.Select(startPosition, token.Value.Length);
                        richTextBox1.SelectionColor = Color.Blue;
                        richTextBox1.SelectionFont = new Font(richTextBox1.Font, FontStyle.Bold); // Устанавливаем жирный шрифт
                    }
                }

                position += token.Value.Length;
            }
            //Возвращаем курсор
            richTextBox1.SelectionStart = selectionStart;
            richTextBox1.SelectionLength = selectionLength;
        }



        private string GetTextBeforeOperation(EditOperation op)
        {
            string currentText = richTextBox1.Text;
            string textBefore = "";

            switch (op.Type)
            {
                case "Insert":
                    // Проверяем op.Position и op.Text.Length
                    if (op.Position >= 0 && op.Position <= currentText.Length && op.Text.Length >= 0 && (op.Position + op.Text.Length) <= currentText.Length)
                    {
                        textBefore = currentText.Remove(op.Position, op.Text.Length);
                    }
                    else
                    {
                        // Обрабатываем ошибку (например, возвращаем currentText)
                        Console.WriteLine($"Ошибка Insert: op.Position = {op.Position}, op.Text.Length = {op.Text.Length}, currentText.Length = {currentText.Length}");
                        textBefore = currentText; // Или другое разумное значение
                    }
                    break;

                case "Delete":
                    // Проверяем op.Position и op.Text
                    if (op.Position >= 0 && op.Position <= currentText.Length && op.Text != null)
                    {
                        textBefore = currentText.Insert(op.Position, op.Text);
                    }
                    else
                    {
                        // Обрабатываем ошибку (например, возвращаем currentText)
                        Console.WriteLine($"Ошибка Delete: op.Position = {op.Position}, op.Text = {op.Text}, currentText.Length = {currentText.Length}");
                        textBefore = currentText; // Или другое разумное значение
                    }
                    break;

                case "Cut":
                    // Проверяем op.Position и op.Text
                    if (op.Position >= 0 && op.Position <= currentText.Length && op.Text != null)
                    {
                        textBefore = currentText.Insert(op.Position, op.Text);
                    }
                    else
                    {
                        // Обрабатываем ошибку (например, возвращаем currentText)
                        Console.WriteLine($"Ошибка Cut: op.Position = {op.Position}, op.Text = {op.Text}, currentText.Length = {currentText.Length}");
                        textBefore = richTextBox1.Text; // Возвращаем исходный текст richTextBox1
                    }
                    break;

                default:
                    textBefore = richTextBox1.Text;
                    break;
            }

            return textBefore;
        }



        private void SaveEditOperation(string type, string text, int position)
        {
            EditOperation newOperation = new EditOperation
            {
                Type = type,
                Text = text,
                Position = position
            };

            undoStack.Push(newOperation);
            redoStack.Clear();
        }



        private void файлToolStripMenuItem_Click(object sender, EventArgs e)
        {
            MenuStrip menuStrip = new MenuStrip();
            ToolStripMenuItem fileMenu = new ToolStripMenuItem("Файл");
            ToolStripMenuItem createMenuItem = new ToolStripMenuItem("Создать");
            ToolStripMenuItem openMenuItem = new ToolStripMenuItem("Открыть");
            ToolStripMenuItem saveMenuItem = new ToolStripMenuItem("Сохранить");
            ToolStripMenuItem saveAsMenuItem = new ToolStripMenuItem("Сохранить как");
            ToolStripMenuItem exitAsMenuItem = new ToolStripMenuItem("Выход");
        }

        private void Создать_Click(object sender, EventArgs e)
        {
            using (SaveFileDialog saveFileDialog = new SaveFileDialog())
            {
                saveFileDialog.InitialDirectory = "c:\\Compiler"; // начальная директория
                saveFileDialog.Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*"; //  фильтр файлов
                saveFileDialog.FilterIndex = 1; // индекс фильтра по умолчанию
                saveFileDialog.FileName = "НовыйФайл.txt"; // имя файла по умолчанию

                // диалог и резул
                if (saveFileDialog.ShowDialog() == DialogResult.OK)
                {
                    string filePath = saveFileDialog.FileName; // получаем путь к выбранному файлу
                    currentFilePath = filePath; // Присваиваем путь переменной currentFilePath
                    try
                    {
                        // Сохранение содержимого richTextBox в файл
                        System.IO.File.WriteAllText(filePath, richTextBox1.Text);
                        MessageBox.Show("Файл успешно сохранен!", "Успешно", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show("Ошибка при сохранении файла: " + ex.Message);
                    }
                }
            }
        }

        private void Выход_Click(object sender, EventArgs e)
        {

            Application.Exit(); // Завершаем приложение
        }

        private void MainForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            // Проверяем, есть ли несохраненные изменения
            if (isTextChanged)
            {
                // Если изменений нет, просто выходим без вопросов
                return;
            }

            // Если есть несохраненные изменения, показываем сообщение с запросом на сохранение
            var saveResult = MessageBox.Show(
                "У вас есть несохранённые изменения. Сохранить перед выходом?",
                "Подтверждение",
                MessageBoxButtons.YesNoCancel,
                MessageBoxIcon.Question
            );

            // Обрабатываем ответ пользователя
            switch (saveResult)
            {
                case DialogResult.Yes:
                    // Пользователь выбрал "Да" (сохранить)
                    if (currentFilePath != null)
                    {
                        // Сохраняем в существующий файл
                        if (!SaveFile())
                        {
                            // Сохранение не удалось, отменяем закрытие формы
                            e.Cancel = true;
                            MessageBox.Show("Не удалось сохранить файл.", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                    }
                    else
                    {
                        // Нет текущего файла, вызываем "Сохранить как..."
                        СохранитьКак_Click(sender, e);

                        // После "Сохранить как..." проверяем, остались ли несохраненные изменения
                        if (isTextChanged)
                        {
                            // Если изменения остались (пользователь отменил сохранение), отменяем закрытие
                            e.Cancel = true;
                        }
                    }
                    break;

                case DialogResult.No:
                    // Пользователь выбрал "Нет" (не сохранять), закрытие продолжится
                    break;

                case DialogResult.Cancel:
                    // Пользователь выбрал "Отмена", отменяем закрытие формы
                    e.Cancel = true;
                    break;
            }
        }




        private void Открыть_Click(object sender, EventArgs e)
        {
            // Проверяем, есть ли несохраненные изменения
            if (!isTextChanged)
            {
                // Спрашиваем пользователя, хочет ли он сохранить текущий файл
                var dialogResult = MessageBox.Show(
                    "У вас есть несохранённые изменения. Сохранить перед открытием нового файла?",
                    "Подтверждение",
                    MessageBoxButtons.YesNoCancel,
                    MessageBoxIcon.Question);

                // Обрабатываем ответ пользователя
                switch (dialogResult)
                {
                    case DialogResult.Yes:
                        // Пытаемся сохранить файл
                        if (currentFilePath != null)
                        {
                            if (!SaveFile()) // Если сохранение не удалось
                                return; // Прерываем операцию открытия
                        }
                        else
                        {
                            СохранитьКак_Click(sender, e);
                            if (isTextChanged) // Если после "Сохранить как..." изменения остались
                                return; // Значит сохранение было отменено, прерываем операцию
                        }
                        break;

                    case DialogResult.No:
                        // Просто продолжаем открытие нового файла
                        break;

                    case DialogResult.Cancel:
                        // Пользователь отменил операцию
                        return;
                }
            }

            // Продолжаем процесс открытия файла
            OpenFileDialog openFileDialog1 = new OpenFileDialog();
            openFileDialog1.Filter = "Текстовые файлы (*.txt)|*.txt|Все файлы (*.*)|*.*";
            openFileDialog1.Title = "Открыть текстовый файл";

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    currentFilePath = openFileDialog1.FileName;
                    richTextBox1.Text = File.ReadAllText(currentFilePath);
                    isTextChanged = false; // Сбрасываем флаг изменений
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Ошибка при открытии файла: " + ex.Message,
                                    "Ошибка",
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Error);
                }
            }
        }

        // Общая функция для проверки необходимости сохранения и его выполнения
        private bool CheckAndSaveFile()
        {
            if (!isTextChanged) // Проверяем, были ли изменения
            {
                var saveResult = MessageBox.Show("У Вас есть несохраненные изменения. Хотите сохранить их?", "Сохранить изменения", MessageBoxButtons.YesNoCancel);

                if (saveResult == DialogResult.Yes)
                {
                    if (currentFilePath != null)
                    {
                        SaveFile();
                    }
                    else
                    {
                        СохранитьКак_Click(this, EventArgs.Empty);
                    }
                    // Проверяем, удалось ли сохранить файл
                    if (isTextChanged) // Если сохранение не удалось
                    {
                        return false; // Отменяем операцию
                    }
                }
                else if (saveResult == DialogResult.Cancel)
                {
                    return false; // Отменяем операцию
                }
            }

            return true; // продолжаем операцию
        }

        private void СохранитьКак_Click(object sender, EventArgs e)
        {
            SaveFileDialog saveFileDialog1 = new SaveFileDialog();
            isTextChanged = false;

            saveFileDialog1.Filter = "Текстовые файлы (*.txt)|*.txt|Все файлы (*.*)|*.*";
            saveFileDialog1.Title = "Сохранить как...";

            if (saveFileDialog1.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    currentFilePath = saveFileDialog1.FileName; // Сохраняем путь к файлу
                    SaveFile();
                }
                catch (Exception ex)
                {
                    MessageBox.Show("Ошибка при сохранении файла: " + ex.Message);
                    isTextChanged = true; // Сохранение не удалось
                }
            }
            else
            {

                //isTextChanged = true; 
            }
        }

        //перезапись
        bool SaveFile()
        {
            try
            {
                File.WriteAllText(currentFilePath, richTextBox1.Text);
                isTextChanged = false; // Сбрасываем флаг изменений после сохранения
                return true;  // Сохранение успешно
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка при сохранении файла: {ex.Message}", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return false;  // Сохранение не удалось
            }


        }

        private void Сохранить_Click_1(object sender, EventArgs e)
        {
            if (currentFilePath != null)
            {
                SaveFile();
            }
            else
            {
                СохранитьКак_Click(sender, e);
            }

            fileSavedSinceLastChange = true;
            isTextChanged = false;
        }







        private void Отменить_Click(object sender, EventArgs e)
        {
            if (undoStack.Count > 1)
            {
                EditOperation lastOperation = undoStack.Pop();

                if (lastOperation.Type == "Cut" && lastOperation.Text.Length > 0)
                {
                    // Отмена вырезания: возвращаем по одному символу с конца
                    string cutText = lastOperation.Text;
                    int insertPosition = lastOperation.Position;

                    EditOperation undoOperation = new EditOperation
                    {
                        Type = "Insert",  // Инвертируем операцию для redo
                        Text = cutText.Substring(cutText.Length - 1),
                        Position = insertPosition
                    };
                    redoStack.Push(undoOperation);

                    ignoreTextChanged = true;
                    richTextBox1.Text = richTextBox1.Text.Insert(insertPosition, cutText.Substring(cutText.Length - 1));
                    ignoreTextChanged = false;

                    cursorPosition = insertPosition;
                }
                else if (lastOperation.Type == "Delete")
                {
                    string currentText = richTextBox1.Text;

                    ignoreTextChanged = true;
                    richTextBox1.Text = richTextBox1.Text.Insert(lastOperation.Position, lastOperation.Text);
                    ignoreTextChanged = false;

                    redoStack.Push(lastOperation);
                }
                else
                {
                    string currentText = richTextBox1.Text;

                    if (string.IsNullOrEmpty(currentText))
                    {
                        MessageBox.Show("Нечего отменять, текст пуст.");
                        return;
                    }

                    int lastPosition = currentText.Length - 1;
                    string deletedChar = currentText.Substring(lastPosition, 1);

                    EditOperation undoOperation = new EditOperation
                    {
                        Type = "Delete",
                        Text = deletedChar,
                        Position = lastPosition
                    };

                    redoStack.Push(undoOperation);

                    ignoreTextChanged = true;
                    richTextBox1.Text = currentText.Remove(lastPosition, 1);
                    ignoreTextChanged = false;
                }

                undoStack.Push(lastOperation);

                richTextBox1.SelectionStart = richTextBox1.TextLength;
                richTextBox1.SelectionLength = 0;
                richTextBox1.Focus();

                isTextChanged = true;
                fileSavedSinceLastChange = false;
            }
            else
            {
                MessageBox.Show("Нечего отменять.");
            }
        }



        private void Повторить_Click_1(object sender, EventArgs e)
        {
            if (redoStack.Count > 0)
            {
                EditOperation operationToRedo = redoStack.Pop();

                ignoreTextChanged = true;

                switch (operationToRedo.Type)
                {
                    case "Insert":
                        richTextBox1.Text = richTextBox1.Text.Insert(operationToRedo.Position, operationToRedo.Text.Substring(0, 1));
                        break;

                    case "Delete":
                        // Добавляем по одному символу с конца
                        if (operationToRedo.Text.Length > 0)
                        {
                            richTextBox1.Text = richTextBox1.Text.Insert(operationToRedo.Position, operationToRedo.Text.Substring(0, 1));
                        }
                        break;

                    case "Cut":
                        richTextBox1.Text = richTextBox1.Text.Insert(operationToRedo.Position, operationToRedo.Text);
                        break;
                }

                ignoreTextChanged = false;

                // cursorPosition = operationToRedo.Position;  // Исходная позиция
                cursorPosition = richTextBox1.TextLength; // Устанавливаем в конец текста

                richTextBox1.SelectionStart = cursorPosition;
                richTextBox1.SelectionLength = 0;
                richTextBox1.Focus();

                isTextChanged = true;
                fileSavedSinceLastChange = false;

                undoStack.Push(operationToRedo);
            }
            else
            {
                MessageBox.Show("Нечего повторять.");
            }
        }


        private void Вырезать_Click(object sender, EventArgs e)
        {
            if (richTextBox1.SelectionLength > 0)
            {
                cuttedText = richTextBox1.SelectedText;
                int start = richTextBox1.SelectionStart;

                SaveEditOperation("Cut", cuttedText, start);
                richTextBox1.Cut(); // Это вызовет TextChanged

                cursorPosition = start;
            }
            else
            {
                MessageBox.Show("Нечего вырезать.");
            }
        }

        private void Копировать_Click_1(object sender, EventArgs e)
        {
            // Проверяем, есть ли выделенный текст
            if (richTextBox1.SelectedText.Length > 0)
            {
                // Копируем выделенный текст 
                Clipboard.SetText(richTextBox1.SelectedText);
            }
        }

        private void Вставить_Click_1(object sender, EventArgs e)
        {
            // Проверяем, есть ли что-то в буфере обмена
            if (Clipboard.ContainsText())
            {
                // Получаем текст из буфера обмена
                string clipboardText = Clipboard.GetText();

                // Определяем, есть ли выделенный текст в RichTextBox
                if (richTextBox1.SelectionLength > 0)
                {
                    // Заменяем выделенный текст текстом из буфера обмена
                    richTextBox1.SelectedText = clipboardText;
                }
                else
                {
                    // Вставляем текст в текущую позицию курсора
                    richTextBox1.Paste();

                }
            }
            else
            {

                MessageBox.Show("В буфере обмена нет текста.");
            }
        }



        private void Удалить_Click(object sender, EventArgs e)
        {
            // Проверяем, выделен ли какой-либо текст в RichTextBox
            if (richTextBox1.SelectionLength > 0)
            {
                // диалоговое окно с вопросом о подтверждении удаления
                DialogResult result = MessageBox.Show("Вы уверены, что хотите удалить выделенный текст?", "Подтверждение удаления", MessageBoxButtons.YesNo, MessageBoxIcon.Question);

                if (result == DialogResult.Yes)
                {
                    richTextBox1.SelectedText = "";
                }
                else
                {

                }
            }
            else
            {

                MessageBox.Show("Необходимо выделить текст для удаления.");
            }
        }


        private void ВыделитьВсе_Click(object sender, EventArgs e)
        {

            richTextBox1.SelectAll();
        }


        private void оПрограммеToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // Создаем и отображаем окно "О программе" с информацией о программе
            string programName = "Текстовый редактор";
            string version = "1.0";
            string author = "Коршунова Ксения"; // Замените на ваше имя
            string description = "Простой текстовый редактор с базовыми функциями.";


            string message = $"{programName} (Версия {version})\n\n" +
                             $"{description}\n\n" +
                             $"Автор: {author}\n";

            MessageBox.Show(message, "О программе", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }



        private void richTextBox2_TextChanged(object sender, EventArgs e)
        {

        }

        private void Шрифт_Click(object sender, EventArgs e)
        {
            using (FontDialog fontDialog = new FontDialog())
            {
                if (fontDialog.ShowDialog() == DialogResult.OK)
                {
                    // Изменение шрифта в окне редактирования
                    richTextBox1.Font = fontDialog.Font;
                    // Изменение шрифта в окне вывода результатов
                    richTextBox2.Font = fontDialog.Font;
                }
            }
        }


        private void Tool_tips()
        {
            toolTip1.SetToolTip(this.Создать, "Создать");
            toolTip1.SetToolTip(this.Открыть, "Открыть");
            toolTip1.SetToolTip(this.Сохранить, "Сохранить");
            toolTip1.SetToolTip(this.Отменить, "Отменить");
            toolTip1.SetToolTip(this.Повторить, "Повторить");
            toolTip1.SetToolTip(this.Копировать, "Копировать");
            toolTip1.SetToolTip(this.Вырезать, "Вырезать");
            toolTip1.SetToolTip(this.Язык, "Язык");
            toolTip1.SetToolTip(this.Шрифт, "Шрифт");
            toolTip1.SetToolTip(this.Вставить, "Вставить");


        }

        private void Язык_Click_1(object sender, EventArgs e)
        {
            if (i == 1) { i = 0; }
            else i = 1;
            switch (i)
            {
                case 0:
                    файлToolStripMenuItem.Text = "File";
                    создатьToolStripMenuItem.Text = "Create";
                    открытьToolStripMenuItem.Text = "Open";
                    сохранитьToolStripMenuItem.Text = "Save";
                    сохранитьКакToolStripMenuItem.Text = "Save as";
                    выходToolStripMenuItem.Text = "Exit";
                    правкаToolStripMenuItem.Text = "Edit";
                    отменитьToolStripMenuItem.Text = "Undo";
                    повторитьToolStripMenuItem.Text = "Redo";
                    вырезатьToolStripMenuItem.Text = "Cut";
                    копироватьToolStripMenuItem.Text = "Copy";
                    вставитьToolStripMenuItem.Text = "Paste";
                    удалитьToolStripMenuItem.Text = "Delete";
                    выделитьВсеToolStripMenuItem.Text = "Select all";
                    текстToolStripMenuItem.Text = "Text";
                    постановкаЗадачиToolStripMenuItem.Text = "Task";
                    грамматикаToolStripMenuItem.Text = "Grammar";
                    классификацияГрамматикиToolStripMenuItem.Text = "Grammar classification";
                    методАнализаToolStripMenuItem.Text = "Aalysis method";
                 
                    тестовыйПримерToolStripMenuItem.Text = "Text example";
                    списокЛитературыToolStripMenuItem.Text = "Bibliography";
                    исходныйКодПрограммыToolStripMenuItem.Text = "Source code";
                    пускToolStripMenuItem.Text = "Run";
                    справкаToolStripMenuItem.Text = "Help";
                    вызовСправкиToolStripMenuItem.Text = "Help";
                    оПрограммеToolStripMenuItem.Text = "About programm";

                    break;

                case 1:
                    файлToolStripMenuItem.Text = "Файл";
                    создатьToolStripMenuItem.Text = "Создать";
                    открытьToolStripMenuItem.Text = "Открыть";
                    сохранитьToolStripMenuItem.Text = "Сохранить";
                    сохранитьКакToolStripMenuItem.Text = "Сохранить как";
                    выходToolStripMenuItem.Text = "Выход";
                    правкаToolStripMenuItem.Text = "Правка";
                    отменитьToolStripMenuItem.Text = "Отменить";
                    повторитьToolStripMenuItem.Text = "Повторить";
                    вырезатьToolStripMenuItem.Text = "Вырезать";
                    копироватьToolStripMenuItem.Text = "Копировать";
                    вставитьToolStripMenuItem.Text = "Вставить";
                    удалитьToolStripMenuItem.Text = "Удалить";
                    выделитьВсеToolStripMenuItem.Text = "Выделить все";
                    текстToolStripMenuItem.Text = "Текст";
                    постановкаЗадачиToolStripMenuItem.Text = "Постановка задачи";
                    грамматикаToolStripMenuItem.Text = "Грамматика";
                    классификацияГрамматикиToolStripMenuItem.Text = "Классификация грамматики";
                    методАнализаToolStripMenuItem.Text = "Метод анализа";
                    
                    тестовыйПримерToolStripMenuItem.Text = "Текстовый пример";
                    списокЛитературыToolStripMenuItem.Text = "Список литературы";
                    исходныйКодПрограммыToolStripMenuItem.Text = "Исходный код программы";
                    пускToolStripMenuItem.Text = "Пуск";
                    справкаToolStripMenuItem.Text = "Справка";
                    вызовСправкиToolStripMenuItem.Text = "Вызов справки";
                    оПрограммеToolStripMenuItem.Text = "О программе";

                    break;
            }
        }
        // Обработчик события DragEnter
        private void MainForm_DragEnter(object sender, DragEventArgs e)
        {
            // Проверяем, что перетаскиваемый объект является файлом
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                e.Effect = DragDropEffects.Copy; // Разрешаем копирование
            }
            else
            {
                e.Effect = DragDropEffects.None; // Запрещаем перетаскивание
            }
        }

        // Обработчик события DragDrop
        private void MainForm_DragDrop(object sender, DragEventArgs e)
        {
            // Получаем массив перетаскиваемых файлов
            string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);

            // Проверяем, что перетащен хотя бы один файл
            if (files != null && files.Length > 0)
            {
                currentFilePath = files[0]; // Берем первый файл

                // Проверяем, что файл имеет расширение .txt
                if (Path.GetExtension(currentFilePath).ToLower() == ".txt")
                {
                    try
                    {
                        // Читаем содержимое файла и отображаем его 
                        richTextBox1.Text = File.ReadAllText(currentFilePath);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Ошибка при открытии файла: {ex.Message}", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                else
                {
                    MessageBox.Show("Поддерживаются только текстовые файлы (.txt).", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            }
        }

        //private void button1_Click_1(object sender, EventArgs e)
        //{
        //    dataGridView1.Rows.Clear();
        //    dataGridView1.Columns.Clear();
        //    richTextBox2.Clear();

        //    // Сброс выделения
        //    richTextBox1.SelectAll();
        //    richTextBox1.SelectionColor = richTextBox1.ForeColor;
        //    richTextBox1.SelectionFont = richTextBox1.Font;
        //    richTextBox1.SelectionLength = 0;

        //    // Анализ
        //    string text = richTextBox1.Text;
        //    SyntaxAnalyzer analyzer = new SyntaxAnalyzer();
        //    List<SyntaxError> errors = analyzer.Parse(text);

        //    // Настройка таблицы
        //    dataGridView1.Columns.Add("Number", "№");
        //    dataGridView1.Columns.Add("Position", "Местоположение");
        //    dataGridView1.Columns.Add("Message", "Сообщение");

        //    dataGridView1.Columns["Number"].Width = 40;
        //    dataGridView1.Columns["Position"].Width = 150;
        //    dataGridView1.Columns["Message"].AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;

        //    // Заполнение данных
        //    for (int i = 0; i < errors.Count; i++)
        //    {
        //        // В методе button1_Click_1 измените строку добавления в DataGridView:
        //        dataGridView1.Rows.Add(
        //            i + 1,
        //            $"с {errors[i].Position} по {errors[i].EndPosition} символы",
        //            errors[i].Message // Просто используем Message без добавления лишнего "(Найдено...)"
        //        );
        //    }

        //    // Подсветка ошибок
        //    HighlightErrorsInText(errors);

        //    // Статус
        //    richTextBox2.Text = errors.Count == 0
        //        ? "Ошибок не обнаружено. Синтаксический анализ завершен успешно."
        //        : $"Найдено ошибок: {errors.Count}";
        //}
        private void button1_Click_1(object sender, EventArgs e)
        {

            dataGridView1.Rows.Clear();
            dataGridView1.Columns.Clear();
            // Настройка таблицы
            dataGridView1.Columns.Add("Number", "Код");
            dataGridView1.Columns.Add("Position", "Местоположение");
            dataGridView1.Columns.Add("Message", "Лексема");

            dataGridView1.Columns["Number"].Width = 40;
            dataGridView1.Columns["Position"].Width = 150;
            dataGridView1.Columns["Message"].AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;

            try
            {
                // Получаем все строки из richTextBox1
                string[] lines = richTextBox1.Lines;
                int count = 1;
                // Обрабатываем каждую строку отдельно
                for (int lineNumber = 0; lineNumber < lines.Length; lineNumber++)
                {
                    string line = lines[lineNumber];
                    // Если нужно удалять незначительные пробелы, раскомментируйте следующую строку
                    // line = RemoveInsignificantSpaces(line);

                    List<Token> tokens = Parse(line);

                    foreach (Token token in tokens)
                    {
                        // Добавляем информацию о строке в dataGridView1
                        dataGridView1.Rows.Add(
                            lineNumber + 1, // Нумерация строк начинается с 1
                            $"с {token.StartPosition} по {token.EndPosition}",
                            token.Messege
                            
                        );
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка: {ex.Message}");
            }
        }
        private List<Token> Parse(string code)
        {
            List<Token> tokens = new List<Token>();

            int line = 1;
            int lineStartPosition = 0;
            int currentState = 0;
            int position = 0;
            bool hasError = false;

            while (position < code.Length && !hasError)
            {
                char current = code[position];
                int charPositionInLine = position - lineStartPosition;
                switch (currentState)
                {
                    case 0://Проверка на DECLARE
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }
                        lineStartPosition = position;
                        bool contains = code.Contains("DECLARE ");
                        if (contains)
                        {
                            position = find("DECLARE ", code);
                            if (lineStartPosition != position)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "Ожидалось DECLARE"
                                ));
                                hasError = true;
                            }
                            else
                            {
                                tokens.Add(new Token(
                                    1, position, position+8, "Ключевое слово DECLARE"
                                ));
                            }

                            position += 7;
                        }
                        else
                        {
                            position += 8;
                            tokens.Add(new Token(
                                    line, lineStartPosition, position, "Ожидалось DECLARE"
                                ));
                            hasError = true;
                        }
                        
                        currentState = 1;
                        break;

                    case 1://Проверка на индификатор
                        lineStartPosition = position;
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }
                        if (lineStartPosition != position)
                        {
                            lineStartPosition = position;
                            while (position < code.Length && (char.IsLetterOrDigit(code[position]) || code[position] == '_') && code[position] != ' ')
                            {
                                position++;
                            }
                            if (position == lineStartPosition)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После DECLARE ожидался индификатор"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    4, lineStartPosition, position, "Идентификатор"
                                ));
                            }
                            currentState = 2;
                        }
                        break;

                    case 2://Проверка на CONSTANT
                           // Пропускаем пробелы
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }

                        lineStartPosition = position;
                        contains = code.Contains(" CONSTANT ");
                        if (contains)
                        {
                            position = find(" CONSTANT ", code) + 1;
                            if (lineStartPosition != position)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После индификатора ожидался CONSTANT"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    2, lineStartPosition, position+8, "Ключевое слово CONSTANT"
                                ));
                            }
                            position += 8;
                        }
                        else
                        {
                            position = find(" INTEGER ", code) + 1;
                            tokens.Add(new Token(
                                    line, lineStartPosition, position, "После индификатора ожидался CONSTANT"
                                ));
                            hasError = true;
                        }
                        currentState = 3;
                        break;

                    case 3://Проверка на NUMERIC
                           // Пропускаем пробелы
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }

                        lineStartPosition = position;
                        contains = code.Contains(" INTEGER ");
                        if (contains)
                        {
                            position = find(" INTEGER ", code) + 1;
                            if (lineStartPosition != position) 
                            { 
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После CONSTANT ожидался INTEGER"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    3, lineStartPosition, position+7, "Ключевое слово INTEGER"
                                ));
                            }
                            position += 7;
                        }
                        else
                        {
                            position = find(" := ", code) + 1;
                            tokens.Add(new Token(
                                    line, lineStartPosition, position, "После CONSTANT ожидался INTEGER"
                                ));
                            hasError = true;
                        }
                        currentState = 4;
                        break;

                    case 4: //Проверка на оператор присваивания
                            // Пропускаем пробелы
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }

                        lineStartPosition = position;
                        contains = code.Contains(" :=");
                        if (contains)
                        {
                            position = find(" :=", code);
                            if (lineStartPosition - 1 != position)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition - 1, position, "После INTEGER ожидался :="
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    5, lineStartPosition, position+2, "Оператор присваивания"
                                ));
                            }
                            position += 2;
                        }

                        else
                        {
                            tokens.Add(new Token(
                                    line, lineStartPosition, position, "После INTEGER ожидался :="
                                ));
                            hasError = true;
                        }

                        currentState = 5;
                        break;

                    case 5: //Проверка на дробное число 
                            // Пропускаем пробелы
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }

                        lineStartPosition = position;
                        // Проверяем, есть ли в строке ":="
                        if (code.Contains(":="))
                        {
                            bool foundDigit = false;
                            while (position < code.Length && !char.IsDigit(code[position]))
                            {
                                position++;
                            }

                            // Запоминаем начало числа
                            int numberStart = position;

                            // Пропускаем все цифры (если они есть)
                            while (position < code.Length && char.IsDigit(code[position]))
                            {
                                position++;
                                foundDigit = true;
                            }

                            // Если цифры не были найдены после ":="
                            if (!foundDigit)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После := ожидалось целое число"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    6, lineStartPosition+1, position-1, "Целое число"
                                ));
                            }
                        }

                        else if (code.Contains(":"))
                        {

                            bool foundDigit = false;
                            while (position < code.Length && !char.IsDigit(code[position]))
                            {
                                position++;
                            }

                            // Запоминаем начало числа
                            int numberStart = position;

                            // Пропускаем все цифры (если они есть)
                            while (position < code.Length && char.IsDigit(code[position]))
                            {
                                position++;
                                foundDigit = true;
                            }

                            // Если цифры не были найдены после ":="
                            if (!foundDigit)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После оператора присваивания ожидалось целое число"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    6, lineStartPosition+1, position-1, "Целое число"
                                ));
                            }
                        }
                        else if (code.Contains("="))
                        {

                            bool foundDigit = false;
                            while (position < code.Length && !char.IsDigit(code[position]))
                            {
                                position++;
                            }

                            // Запоминаем начало числа
                            int numberStart = position;

                            // Пропускаем все цифры (если они есть)
                            while (position < code.Length && char.IsDigit(code[position]))
                            {
                                position++;
                                foundDigit = true;
                            }

                            // Если цифры не были найдены после ":="
                            if (!foundDigit)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После оператора присваивания ожидалось целое число"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    6, lineStartPosition+1, position-1, "Целое число"
                                ));
                            }
                        }

                        while (position < code.Length && (char.IsDigit(code[position])))
                        {
                            position++;
                        }

                        //position--;
                        currentState = 6;
                        if (position == code.Length)
                        {
                            if (code[position - 1] != ';')
                            {
                                tokens.Add(new Token(
                                        line, position, position, "; Ожидалась в конце"
                                    ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    7, position, position, ";"
                                ));
                            }
                        }
                        break;

                    case 6:
                        // Пропускаем пробелы
                        while (char.IsWhiteSpace(current))
                        {
                            position++;
                            current = code[position];
                        }
                        lineStartPosition = position;
                        if (code.Contains(";"))
                        {
                            position = find(";", code);
                            if (lineStartPosition != position)
                            {
                                tokens.Add(new Token(
                                    line, lineStartPosition, position, "После целого числа ожидалась ;"
                                ));
                                hasError = true;
                            }
                            if (!hasError)
                            {
                                tokens.Add(new Token(
                                    7, position, position, ";"
                                ));
                            }
                        }
                        if (!(code.Contains(";")))
                        {
                            tokens.Add(new Token(
                                    line, lineStartPosition, position, "После целого числа ожидалась ;"
                                ));
                            hasError = true;
                        }
                        position += 1;
                        currentState = 7;
                        break;
                }
            }
            return tokens;
        }
        private int find(string fs, string code)
        {
            return code.IndexOf(fs);
        }
        private string RemoveInsignificantSpaces(string input)
        {
            StringBuilder result = new StringBuilder();
            bool inStringLiteral = false;
            bool spaceAdded = true; // Начинаем с true, чтобы не добавлять пробелы в начале

            for (int i = 0; i < input.Length; i++)
            {
                char c = input[i];

                if (c == '\'')
                {
                    inStringLiteral = !inStringLiteral;
                    result.Append(c);
                    spaceAdded = false;
                }
                else if (inStringLiteral)
                {
                    result.Append(c);
                    spaceAdded = false;
                }
                else if (char.IsWhiteSpace(c))
                {
                    if (!spaceAdded && (i + 1 < input.Length) && !IsOperatorChar(input[i + 1]))
                    {
                        result.Append(' ');
                        spaceAdded = true;
                    }
                }
                else
                {
                    result.Append(c);
                    spaceAdded = false;
                }
            }

            return result.ToString().Trim();
        }
        private bool IsOperatorChar(char c)
        {
            return c == ':' || c == '=' || c == '+' || c == '-' || c == '*' || c == '/' || c == ';';
        }
        private class Token
        {
            public int Line { get; }
            public int StartPosition { get; }
            public int EndPosition { get; }
            public string Messege { get; }

            public Token(int line, int startPos, int endPos, string messege)
            {
                Line = line;
                StartPosition = startPos;
                EndPosition = endPos;
                Messege = messege;
            }
        }
        private void HighlightErrorsInText(List<SyntaxError> errors)
        {
            if (errors == null || errors.Count == 0) return;

            int selectionStart = richTextBox1.SelectionStart;
            int selectionLength = richTextBox1.SelectionLength;

            foreach (var error in errors)
            {
                int start = Math.Max(0, error.Position - 1);
                int end = Math.Min(error.EndPosition - 1, richTextBox1.TextLength - 1);
                int length = end - start + 1;

                if (start < richTextBox1.TextLength)
                {
                    richTextBox1.Select(start, length);
                    richTextBox1.SelectionColor = Color.Red;
                    richTextBox1.SelectionFont = new Font(richTextBox1.Font, FontStyle.Bold);
                }
            }

            richTextBox1.SelectionStart = selectionStart;
            richTextBox1.SelectionLength = selectionLength;
            richTextBox1.SelectionColor = richTextBox1.ForeColor;
            richTextBox1.SelectionFont = richTextBox1.Font;
        }
        private int ExtractEndPosition(string location)
        {
            // Пример: "Строка 1, c 1 по 7 символы"
            int startIndex = location.IndexOf(" по ") + 4;
            int endIndex = location.IndexOf(" символы", startIndex);
            if (startIndex >= 4 && endIndex > startIndex)
            {
                string endPositionString = location.Substring(startIndex, endIndex - startIndex);
                if (int.TryParse(endPositionString, out int endPosition))
                {
                    return endPosition - 1; // Вычитаем 1, так как нумерация в RichTextBox начинается с 0
                }
            }
            return -1; // Ошибка
        }

        private void Пуск_Click(object sender, EventArgs e)
        {
            button1_Click_1(sender, e);

        }


        public class LexicalAnalyzer
        {
            public enum TokenType
            {

                DECLARE = 1,                // code = 1,  Ключевое слово DECLARE
                CONSTANT = 2,               // code = 2,  Ключевое слово CONSTANT
                INTEGER = 3,                // code = 3,  Ключевое слово INTEGER
                IDENTIFIER = 4,             // code = 4,  Идентификатор
                WHITESPACE = 5,             // code = 5,  Пробел - разделитель
                NEWLINE = 6,                // code = 6,  Перенос на следующую строку - разделитель
                ASSIGNMENT = 7,               // code = 7,  Оператор присваивания
                SIGN = 8,                     // code = 8,  Знак (+ или -)
                INTEGER_LITERAL = 9,        // code = 9,  Целое без знака
                END_OPERATOR = 10,            // code = 10, Конец оператора
                INVALID = 11,               // ERROR, Недопустимый символ
            }

            public struct Token
            {
                public TokenType Type;
                public string Value;
                public int Line;
                public int Column;
            }

            public List<Token> Scan(string text)
            {
                List<Token> tokens = new List<Token>();
                string[] lines = text.Split(new[] { Environment.NewLine }, StringSplitOptions.None); // Разделяем на строки

                for (int lineNumber = 0; lineNumber < lines.Length; lineNumber++)
                {
                    string line = lines[lineNumber];
                    int columnNumber = 0;
                    while (columnNumber < line.Length)
                    {
                        Token? token = GetNextToken(line, columnNumber, lineNumber);
                        if (token.HasValue)
                        {
                            tokens.Add(token.Value);
                            columnNumber += token.Value.Value.Length; // Сдвигаем позицию чтения
                        }
                        else
                        {
                            // Если не удалось выделить токен, это недопустимый символ
                            Console.WriteLine($"Недопустимый символ в строке {lineNumber + 1}, колонке {columnNumber + 1}: {line[columnNumber]}");
                            columnNumber++; // Пропускаем недопустимый символ
                        }
                    }
                }
                return tokens;
            }

            private Token? GetNextToken(string line, int columnNumber, int lineNumber)
            {
                if (columnNumber >= line.Length) return null;

                // Пропускаем пробелы
                if (char.IsWhiteSpace(line[columnNumber]))
                {
                    int end = columnNumber;
                    while (end < line.Length && char.IsWhiteSpace(line[end])) end++;
                    return new Token { Type = TokenType.WHITESPACE, Value = line.Substring(columnNumber, end - columnNumber), Line = lineNumber + 1, Column = columnNumber + 1 };
                }

                // Проверяем на ключевые слова и идентификаторы
                Match keywordMatch = Regex.Match(line.Substring(columnNumber), @"^(DECLARE|CONSTANT|INTEGER)\b", RegexOptions.IgnoreCase);
                if (keywordMatch.Success)
                {
                    string keyword = keywordMatch.Value;
                    return new Token { Type = (TokenType)Enum.Parse(typeof(TokenType), keyword.ToUpper()), Value = keyword, Line = lineNumber + 1, Column = columnNumber + 1 };
                }

                // Проверяем на идентификаторы
                Match identifierMatch = Regex.Match(line.Substring(columnNumber), @"^[a-zA-Z_][a-zA-Z0-9_]*");
                if (identifierMatch.Success)
                {
                    string identifier = identifierMatch.Value;
                    return new Token { Type = TokenType.IDENTIFIER, Value = identifier, Line = lineNumber + 1, Column = columnNumber + 1 };
                }
                // Проверяем на знаки + и -
                if (line[columnNumber] == '+' || line[columnNumber] == '-')
                {
                    return new Token { Type = TokenType.SIGN, Value = line[columnNumber].ToString(), Line = lineNumber + 1, Column = columnNumber + 1 };
                }

                // Проверяем на оператор присваивания
                if (line.Substring(columnNumber).StartsWith(":="))
                {
                    return new Token { Type = TokenType.ASSIGNMENT, Value = ":=", Line = lineNumber + 1, Column = columnNumber + 1 };
                }

                // Проверяем на точку с запятой
                if (line[columnNumber] == ';')
                {
                    return new Token { Type = TokenType.END_OPERATOR, Value = ";", Line = lineNumber + 1, Column = columnNumber + 1 };
                }

                // Проверяем на целое число
                Match integerMatch = Regex.Match(line.Substring(columnNumber), @"^[0-9]+");
                if (integerMatch.Success)
                {
                    string integerLiteral = integerMatch.Value;
                    return new Token { Type = TokenType.INTEGER_LITERAL, Value = integerLiteral, Line = lineNumber + 1, Column = columnNumber + 1 };
                }

                // Если не удалось выделить ни один токен, это недопустимый символ
                return new Token { Type = TokenType.INVALID, Value = line[columnNumber].ToString(), Line = lineNumber + 1, Column = columnNumber + 1 };
            }


        }

        private void отменитьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Отменить_Click(sender, e);
        }

        private void повторитьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Повторить_Click_1(sender, e);
        }

        private void вырезатьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Вырезать_Click(sender, e);

        }

        private void копироватьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Копировать_Click_1(sender, e);
        }

        private void вставитьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Вставить_Click_1(sender, e);
        }

        private void удалитьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Удалить_Click(sender, e);
        }

        private void выделитьВсеToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ВыделитьВсе_Click(sender, e);
        }

        private void создатьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Создать_Click(sender, e);
        }

        private void открытьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Открыть_Click(sender, e);
        }

        private void сохранитьToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Сохранить_Click_1(sender, e);
        }

        private void сохранитьКакToolStripMenuItem_Click(object sender, EventArgs e)
        {
            СохранитьКак_Click(sender, e);
        }

        private void выходToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Выход_Click(sender, e);
        }

        private void вызовСправкиToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string htmlFilePath = Path.Combine(Application.StartupPath, "TextFile1.html");
            Process.Start("chrome.exe", htmlFilePath); // Для Chrome
        }

        private void пускToolStripMenuItem_Click(object sender, EventArgs e)
        {
            button1_Click_1(sender, e);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            вызовСправкиToolStripMenuItem_Click(sender, e);
        }

        private void dataGridView1_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {

        }

        private void постановкаЗадачиToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string htmlFilePath = @"C:\Users\kskor\Downloads\данилу (3)\данилу\ProblemStatement.html"; 

            if (File.Exists(htmlFilePath))
            {
                Process.Start(new ProcessStartInfo(htmlFilePath) { UseShellExecute = true });
            }
            else
            {
                MessageBox.Show("HTML файл не найден!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void грамматикаToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string htmlFilePath = @"C:\Users\kskor\Downloads\данилу (3)\данилу\Grammar.html";

            if (File.Exists(htmlFilePath))
            {
                Process.Start(new ProcessStartInfo(htmlFilePath) { UseShellExecute = true });
            }
            else
            {
                MessageBox.Show("HTML файл не найден!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void классификацияГрамматикиToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string htmlFilePath = @"C:\Users\kskor\Downloads\данилу (3)\данилу\GrammarClassification.html";

            if (File.Exists(htmlFilePath))
            {
                Process.Start(new ProcessStartInfo(htmlFilePath) { UseShellExecute = true });
            }
            else
            {
                MessageBox.Show("HTML файл не найден!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void методАнализаToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string htmlFilePath = @"C:\Users\kskor\Downloads\данилу (3)\данилу\MethodOfAnalysis.html";

            if (File.Exists(htmlFilePath))
            {
                Process.Start(new ProcessStartInfo(htmlFilePath) { UseShellExecute = true });
            }
            else
            {
                MessageBox.Show("HTML файл не найден!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        

        private void тестовыйПримерToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // Путь к файлу с тестовым примером (можете изменить на свой)
            string filePath = "C:\\Users\\kskor\\Downloads\\данилу (3)\\данилу\\correct_test_case.txt";

            try
            {
                // Проверяем существование файла
                if (File.Exists(filePath))
                {
                    // Читаем весь текст из файла
                    string testCaseText = File.ReadAllText(filePath, Encoding.UTF8);

                    // Вставляем текст в поле ввода (предполагается, что оно называется textBoxInput)
                    richTextBox1.Text = testCaseText;

                    // ИЛИ, если используется RichTextBox (для форматирования)
                    // richTextBoxInput.Text = testCaseText;
                }
                else
                {
                    MessageBox.Show("Файл с тестовым примером не найден!", "Ошибка",
                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка при загрузке тестового примера:\n{ex.Message}", "Ошибка",
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void списокЛитературыToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string htmlFilePath = @"C:\Users\kskor\Downloads\данилу (3)\данилу\ListOfLiterature.html";

            if (File.Exists(htmlFilePath))
            {
                Process.Start(new ProcessStartInfo(htmlFilePath) { UseShellExecute = true });
            }
            else
            {
                MessageBox.Show("HTML файл не найден!", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void исходныйКодПрограммыToolStripMenuItem_Click(object sender, EventArgs e)
        {

        }
    }
    public class SyntaxError
    {
        public string Message { get; set; }
        public int Position { get; set; }
        public int EndPosition { get; set; }
        public string DiscardedFragment { get; set; }
        public string Expected { get; set; }
    }

    public class SyntaxAnalyzer
    {
        public List<SyntaxError> Parse(string input)
        {
            List<SyntaxError> errors = new List<SyntaxError>();
            int pos = 0;
            input = input.Trim();

            // 1. Проверка DECLARE (критическая ошибка)
            if (!ExpectKeyword(input, ref pos, "DECLARE", errors))
            {
                AddError(errors, input, pos, 7, "Ожидалось ключевое слово", "DECLARE");
                return errors; // Прекращаем анализ после критической ошибки
            }

            // 2. Проверка идентификатора
            if (!ExpectIdentifier(input, ref pos, errors))
            {
                AddError(errors, input, pos, 1, "Ожидался идентификатор", "буква или _");
                SkipToNextToken(input, ref pos);
            }

            // 3. Проверка CONSTANT
            if (!ExpectKeyword(input, ref pos, "CONSTANT", errors))
            {
                string fragment = GetFragmentToNextWhitespace(input, pos);
                AddError(errors, input, pos, fragment.Length, "Ожидалось ключевое слово", "CONSTANT");
                SkipToNextToken(input, ref pos);
            }

            // 4. Проверка типа данных
            if (!ExpectType(input, ref pos, errors))
            {
                SkipToNextToken(input, ref pos);
            }

            // 5. Проверка оператора присваивания
            if (!ExpectAssignment(input, ref pos, errors))
            {
                AddError(errors, input, pos, 2, "Ожидался оператор", "':=' или '='");
                SkipToNextToken(input, ref pos);
            }

            // 6. Проверка значения
            if (!ExpectValue(input, ref pos, errors))
            {
                AddError(errors, input, pos, 1, "Ожидалось значение", "целое число");
                SkipToNextToken(input, ref pos);
            }

            // 7. Проверка точки с запятой
            if (!ExpectSemicolon(input, ref pos, errors))
            {
                AddError(errors, input, pos, 1, "Ожидался символ", "';'");
            }

            return errors;
        }

        private bool ExpectType(string input, ref int pos, List<SyntaxError> errors)
        {
            SkipWhitespace(input, ref pos);
            int startPos = pos;

            if (ExpectKeyword(input, ref pos, "INTEGER", null) ||
                ExpectKeyword(input, ref pos, "REAL", null) ||
                ExpectKeyword(input, ref pos, "STRING", null))
            {
                return true;
            }

            string fragment = GetFragmentToNextWhitespace(input, startPos);
            if (!string.IsNullOrEmpty(fragment))
            {
                AddError(errors, input, startPos, fragment.Length,
                        "Ожидался тип данных", "INTEGER, REAL или STRING");
            }
            return false;
        }

        private bool ExpectKeyword(string input, ref int pos, string keyword, List<SyntaxError> errors)
        {
            SkipWhitespace(input, ref pos);
            if (pos + keyword.Length <= input.Length &&
                string.Compare(input, pos, keyword, 0, keyword.Length, true) == 0)
            {
                pos += keyword.Length;
                return true;
            }
            return false;
        }

        private bool ExpectIdentifier(string input, ref int pos, List<SyntaxError> errors)
        {
            SkipWhitespace(input, ref pos);
            if (pos < input.Length && (char.IsLetter(input[pos]) || input[pos] == '_'))
            {
                pos++;
                while (pos < input.Length && (char.IsLetterOrDigit(input[pos]) || input[pos] == '_'))
                {
                    pos++;
                }
                return true;
            }
            return false;
        }

        private bool ExpectAssignment(string input, ref int pos, List<SyntaxError> errors)
        {
            SkipWhitespace(input, ref pos);

            if (pos + 2 <= input.Length && input.Substring(pos, 2) == ":=")
            {
                pos += 2;
                return true;
            }

            if (pos < input.Length && input[pos] == '=')
            {
                pos += 1;
                return true;
            }

            return false;
        }

        private bool ExpectValue(string input, ref int pos, List<SyntaxError> errors)
        {
            SkipWhitespace(input, ref pos);
            if (pos >= input.Length) return false;

            if (input[pos] == '"')
            {
                pos++;
                while (pos < input.Length && input[pos] != '"') pos++;
                if (pos < input.Length && input[pos] == '"')
                {
                    pos++;
                    return true;
                }
                return false;
            }

            bool hasDigits = false;
            if (input[pos] == '+' || input[pos] == '-')
            {
                pos++;
            }
            while (pos < input.Length && char.IsDigit(input[pos]))
            {
                hasDigits = true;
                pos++;
            }
            return hasDigits;
        }

        private bool ExpectSemicolon(string input, ref int pos, List<SyntaxError> errors)
        {
            SkipWhitespace(input, ref pos);

            if (pos < input.Length && input[pos] == ';')
            {
                pos++;
                return true;
            }

            return false;
        }

        private string GetFragmentToNextWhitespace(string input, int startPos)
        {
            int endPos = startPos;
            while (endPos < input.Length && !char.IsWhiteSpace(input[endPos]))
            {
                endPos++;
            }
            return endPos > startPos ? input.Substring(startPos, endPos - startPos) : "";
        }

        private void AddError(List<SyntaxError> errors, string input, int pos, int length,
         string message, string expected)
        {
            errors.Add(new SyntaxError
            {
                Position = pos + 1,
                EndPosition = pos + length,
                Message = $"{message} '{expected}'",
                Expected = expected
            });
        }

        private void SkipToNextToken(string input, ref int pos)
        {
            while (pos < input.Length && !char.IsWhiteSpace(input[pos]))
            {
                pos++;
            }
            SkipWhitespace(input, ref pos);
        }

        private void SkipWhitespace(string input, ref int pos)
        {
            while (pos < input.Length && char.IsWhiteSpace(input[pos]))
            {
                pos++;
            }
        }
    }
}

  
