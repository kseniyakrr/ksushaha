# Лабораторная работа №1

**Тема:** Разработка пользовательского интерфейса (GUI) для языкового процессора.
**Цель:** Разработать приложение – текстовый редактор.

## Основные функции

### Меню "Файл"
- **Создать** - создает новый файл или проект
- **Открыть** - открывает существующий файл или проект из файловой системы
- **Сохранить** - сохраняет текущий файл
- **Сохранить как** - сохраняет файл с новым именем или в новом месте
- **Выход** - закрывает IDE

### Меню "Правка"
- **Отменить** - отменяет последнее действие
- **Повторить** - повторяет отмененное действие
- **Вырезать** - удаляет выделенный текст в буфер обмена
- **Копировать** - копирует выделенный текст в буфер обмена
- **Вставить** - вставляет содержимое буфера обмена
- **Удалить** - удаляет выделенный текст без сохранения в буфер
- **Выделить все** - выделяет весь текст в текущем документе

## Лабораторная работа №2: Разработка лексического анализатора (сканера)

**Тема:** разработка лексического анализатора (сканера).

**Цель работы:** изучить назначение лексического анализатора. Спроектировать алгоритм и выполнить программную реализацию сканера.

| № | Тема | Пример верной строки | Справка |
| ------ | ------ | ------ | ------ |
| 42 | Объявление и инициализация целочисленной константы в СУБД PostgreSQL | DECLARE product_price CONSTANT INTEGER := 150; | [ссылка](https://www.commandprompt.com/education/constants-in-postgresql-explained-with-examples/) |

**В соответствии с вариантом задания необходимо:**

1. Спроектировать диаграмму состояний сканера.
2. Разработать лексический анализатор, позволяющий выделить в тексте лексемы, иные символы считать недопустимыми (выводить ошибку).
3. Встроить сканер в ранее разработанный интерфейс текстового редактора. Учесть, что текст для разбора может состоять из множества строк.

**Входные данные:** строка (текст программного кода).

**Выходные данные:** последовательность условных кодов, описывающих структуру разбираемого текста с указанием места положения и типа.

### Примеры допустимых строк

```sql
DECLARE product_price CONSTANT INTEGER = +150;
```

```sql
DECLARE total_amount CONSTANT INTEGER := -150;
```

```sql
DECLARE productPrice CONSTANT INTEGER := +150;
```

```sql
DECLARE expense_1_amount CONSTANT INTEGER := -50;
```

```sql
DECLARE product_price CONSTANT INTEGER := -150; DECLARE total_2 CONSTANT INTEGER := 50;
```

```sql
DECLARE productPrice3 CONSTANT INTEGER := 150; DECLARE expense_amount_4 CONSTANT INTEGER := -50;
```

### Диаграмма состояний сканера

![Диаграмма состояний сканера] ![image](https://github.com/user-attachments/assets/44d99fc6-9d85-4aa1-8eda-adc1610e1330)


### Тестовые примеры

1. **Тест №1.** Пример, показывающий все возможные лексемы, которые могут быть найдены лексическим анализатором.
   
   ![image](https://github.com/user-attachments/assets/727a706a-8452-4299-99d6-f41a3d9b5439)


## Лабораторная работа №3: Разработка синтаксического анализатора (парсера)

**Тема:** разработка синтаксического анализатора (парсера).

**Цель работы:** изучить назначение синтаксического анализатора, спроектировать алгоритм и выполнить программную реализацию парсера.

| № | Тема | Пример верной строки | Справка |
| ------ | ------ | ------ | ------ |
| 42 | Объявление и инициализация целочисленной константы в СУБД PostgreSQL | DECLARE product_price CONSTANT INTEGER := 150; | 



**В соответствии с вариантом задания необходимо:**
1. Разработать автоматную грамматику.
2. Спроектировать граф конечного автомата (перейти от автоматной грамматики к конечному автомату).
3. Выполнить программную реализацию алгоритма работы конечного автомата.
4. Встроить разработанную программу в интерфейс текстового редактора, созданного на первой лабораторной работе.

### Грамматика

G[&lt;ЦК&gt; = &lt;целочисленная константа&gt;]:

V<sub>T</sub> = { ‘DECLARE’, ‘CONSTANT’, ‘INTEGER’, ‘a’…’z’, ‘A’…’Z’, ‘0’…’9’, ‘:’, ‘;’, ‘+’, ‘-‘, ‘=’, ‘_’ }

V<sub>N</sub> = { &lt;ЦК&gt;, E, CONST, INT, ASSIGN, NUMBER, SIGN, UNSIGNEDINT, END, Б, Ц }

P = {
1. &lt;ЦК&gt; → ‘DECLARE’ E
2. E → Б { Б | Ц | ‘_’ } CONST
3. CONST → ‘CONSTANT’ INT
4. INT → ‘INTEGER’ ASSIGN
5. ASSIGN → ‘:=’ NUMBER | ‘=’ NUMBER
6. NUMBER → SIGN UNSIGNEDINT
7. SIGN → [ ‘+’ | ‘-‘ ]
8. UNSIGNEDINT → Ц { Ц } END
9. END → ‘;’
10. Б → ‘a’ | ‘b’ | … | ‘z’ | ‘A’ | ‘B’ | … | ‘Z’
11. Ц → ‘0’ | ‘1’ | … | ‘9’

}

### Классификация грамматики

   Согласно классификации Хомского, грамматика G[Z] является полностью автоматной.

### Граф конечного автомата

![Граф конечного автомата] ![image](https://github.com/user-attachments/assets/da16dd6a-0adc-4dde-bbe8-f2b8bbdb3b23)


### Тестовые примеры

1. **Тест №1.** Все выражения написаны корректно.

![image](https://github.com/user-attachments/assets/caca73b3-560f-434e-bea8-72e449a4c328)
 
3. **Тест №2.** Пример ошибок.
![image](https://github.com/user-attachments/assets/a70aef04-0169-4b7c-b4d5-6bf96bae0c77)

4. **Тест №3.** Пример ошибок.
![image](https://github.com/user-attachments/assets/92ce127e-f0ee-456d-a72a-006502c2cf4e)

## Лабораторная работа №4: Нейтрализация ошибок (метод Айронса)

**Тема**: нейтрализация ошибок (метод Айронса).

**Цель работы:** реализовать алгоритм нейтрализации синтаксических ошибок и дополнить им программную реализацию парсера.

### Метод Айронса

Разрабатываемый синтаксический анализатор построен на базе автоматной грамматики. При нахождении лексемы, которая не соответствует грамматике предлагается свести алгоритм нейтрализации к последовательному
удалению следующего символа во входной цепочке до тех пор, пока следующий символ не окажется одним из допустимых в данный момент разбора.

Этот алгоритм был мной уже реализован в Лабораторной работе №3. В таблице ошибок выводятся их местоположение и текст ошибки, содержащий информацию об отброшенном фрагменте.


# Лабораторная работа 5
**Тема:** Включение семантики в анализатор. Создание внутренней формы представления программы.
**Цель работы:** Дополнить анализатор, разработанный в рамках лабораторных работ, этапом формирования внутренней формы представления программы.
- 1 вариант. В качестве внутренней формы представления программы выберем польскую инверсную запись (ПОЛИЗ). Эта форма представления наглядна и достаточно проста для последующей интерпретации, которая может быть выполнена с использованием стека.

- Задание:

Реализовать в текстовом редакторе поиск лексических и синтаксических ошибок для грамматики G[<E>]. Реализовать данную КС-граммматику методом рекурсивного спуска:
1. E → TA
2. A → ε | + TA | - TA 
3. T → ОВ 
4. В → ε | *ОВ | /ОВ 
5. О → num | (E) 
6. num  → digit {digit}
   
2) Реализовать алгоритм записи арифметических выражений в ПОЛИЗ и алгоритм вычисления выражений в ПОЛИЗ.

### Тестовые примеры

1. **Тест №1. Без ошибок**
![image](https://github.com/user-attachments/assets/95ff01bd-434d-418a-b2b8-246dda9d3050)

3. **Тест №2. Пример с ошибкой**
![image](https://github.com/user-attachments/assets/ba958618-b658-46dc-aee4-6790760c34c4)

5. **Тест №3. Пример с ошибкой** 
![image](https://github.com/user-attachments/assets/3966dafc-cfc3-4595-b7b0-87ec596e9faa)


# Лабораторная работа 6  
**Тема:** Реализация алгоритма поиска подстрок с помощью регулярных выражений  
**Цель:** Реализовать алгоритм поиска в тексте подстрок, соответствующих заданным регулярным выражениям
**Задания:**
- (17). Построить РВ, описывающее пароль (набор строчных и
прописных латинских букв, цифр и символов).
- (10). Построить РВ, описывающее номера карт, принадлежащих
платежной системе UnionPay.
- (12). Построить РВ, описывающее путь к файлу в Unix.


**Примеры регулярных выражений:**
  - Пароль: Passw0rd!
  - Номер карты: 6223456789012345
  - Путь: /home/user/file.txt

![image](https://github.com/user-attachments/assets/6b054f8c-a2fd-4821-b4ed-b61c70a49249)

- рис.11 Пример РВ: Пароль

![image](https://github.com/user-attachments/assets/faebaccd-7979-4b77-a7d4-c304c4e2032f)

- рис.12 Пример РВ: Номер карты

![image](https://github.com/user-attachments/assets/97477810-5cfe-476d-bbc0-eb0cc8b42dc7)

- рис.13 Пример РВ: Путь


# Лабораторная работа 7

**Тема лабораторной работы:** Преобразование и анализ кода с использованием Clang и LLVM.

**Цель работы:** Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

**Задание:** 

1. Установить Clang и LLVM;

2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

3. Использовать opt для применения базовой комплексной оптимизации (например, О2);

4. Построить граф потока управления (CFG) для оптимизированной программы;
  
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

![image](https://github.com/user-attachments/assets/253ed355-a1af-4126-b6fe-db7532d201c2)

рис.13 Установка необходимых пакетов

![image](https://github.com/user-attachments/assets/3976c833-065a-4a97-8bfc-96a557ab9069)

рис.14 Получение AST Содержимое 

![image](https://github.com/user-attachments/assets/e45b98ff-934c-452e-81e6-afe269ce5d84)

рис.15 Генерация LLVM IR

![image](https://github.com/user-attachments/assets/603e9883-9af5-4049-806d-0b1a7d6dd476)

рис.16 Создание main_O0.ll 

![image](https://github.com/user-attachments/assets/311a4e74-232a-4509-9306-9fa00e0f9421)

рис.17 Создание main_O2.ll

![image](https://github.com/user-attachments/assets/226a5ce7-c0b8-4098-a070-692fe132ad1e)

рис.18 Сравнение двух файлов

![image](https://github.com/user-attachments/assets/f252d0eb-b922-46ba-bea7-e65670997a00)

рис.19 Генерация .dot-файлов CFG для функций 

![image](https://github.com/user-attachments/assets/a235a3a7-9e10-46f4-b643-93a1e2ee2f34)

рис.20 Установка библиотеки Graphviz

![image](https://github.com/user-attachments/assets/cabf615a-13ef-4ff6-9d26-3d017710d885)

рис.21 xdg-open cfg_main.png

![image](https://github.com/user-attachments/assets/248459b1-025f-4fe0-bd60-174051a669a0)

рис.22 xdg-open cfg_square.png

## Ответы на контрольные вопросы

### 1. Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это компилятор для C, C++ и Objective-C, часть LLVM. Он преобразует исходный код в машинный или промежуточный (IR), выполняя препроцессинг, анализ и оптимизацию.  

### 2. Что представляет собой LLVM и как он используется в современных компиляторах?  
LLVM — это модульная платформа для разработки компиляторов, использующая универсальное промежуточное представление (IR) для оптимизации и генерации машинного кода. В современных компиляторах (Clang, Rust, Swift) LLVM отвечает за анализ, оптимизацию и поддержку разных архитектур процессоров.  

### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
AST отражает структуру исходного кода в виде дерева с узлами (операторы, выражения, объявления), сохраняя высокоуровневую семантику языка. LLVM IR — это низкоуровневое линейное представление, близкое к машинному коду, оптимизированное для анализа и преобразований (например, циклов или арифметики).  
Ключевое отличие: AST зависит от языка (C++, Rust и т.д.), а LLVM IR — универсален и используется для кросс-языковой оптимизации и генерации кода под разные процессоры.  

### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
Промежуточное представление (IR) нужно, чтобы отделить анализ исходного кода от генерации машинного кода, упрощая поддержку новых языков и архитектур. Оно позволяет применять универсальные оптимизации до привязки к конкретному процессору. 

### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?  
**alloca** в LLVM IR выделяет память в стеке функции под локальные переменные и возвращает указатель на неё. Используется для хранения адресуемых данных. Автоматически освобождается при завершении функции, аналогично обычным стековым переменным в C.  

### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
Оптимизация кода делает программу быстрее и компактнее, удаляя лишние операции и эффективнее используя ресурсы процессора. Главные задачи — ускорение вычислений, уменьшение размера кода и адаптация под конкретное оборудование. Без неё программы работали бы медленнее и тратили больше памяти.  

### 7. Что такое SSA-форма и почему она важна при оптимизации программ?  
SSA-форма (Static Single Assignment) — это представление программы, где каждая переменная инициализируется лишь единожды, что делает зависимости между данными явными и однозначными.  
Ключевая польза:  
Позволяет компилятору легко отслеживать поток данных, упрощая такие оптимизации, как удаление общих подвыражений и продвижение констант.  
Особенно полезна для анализа и преобразования циклов, где важно точно определять изменяемые переменные.  

### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?  
Граф потока управления (CFG) — это визуальное представление структуры программы в виде связанных блоков кода, где каждый блок содержит последовательность инструкций, а стрелки между ними показывают возможные пути выполнения. Такой граф помогает компилятору анализировать и оптимизировать код, выявляя недостижимые участки, избыточные условия и потенциальные точки ветвления. Благодаря CFG можно эффективно применять оптимизации, связанные с анализом циклов, предсказанием переходов и распределением ресурсов.

### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?  
В LLVM IR арифметические операции записываются как инструкции с явным указанием типа, например:  
%res = add i32 %a, %b.  
Каждая операция создаёт новое значение в SSA-форме, что упрощает анализ и оптимизацию кода.
Для умножения,сложения,вычитания и деления используются mul,add,sub,sdiv, а типы данных (как i32) всегда указываются явно, например: %sum = mul i32 %x, %y.  

### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
Функции в LLVM IR являются самостоятельными единицами оптимизации, поскольку их изолированная структура позволяет применять преобразования локально, не анализируя всю программу. Это даёт возможность эффективно выполнять как внутрипроцедурные оптимизации, так и межпроцедурные (анализируя взаимодействия между функциями). Такой подход значительно ускоряет процесс компиляции и улучшает качество оптимизаций.  

### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
Короткая функция в LLVM IR, вызываемая единожды, обычно подставляется на месте вызова и затем удаляется. Это устраняет накладные расходы на вызов.  

### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
Использование LLVM IR и CFG даёт ключевые преимущества для автоматических оптимизаций по сравнению с анализом исходного C-кода:  
1. Абстракция от языка — IR унифицирует разные языки (C, C++, Rust и др.), позволяя применять общие оптимизации без привязки к синтаксису.  
2. Точный контроль потока — CFG явно показывает ветвления и циклы, упрощая анализ достижимости и удаление мёртвого кода.  
3. Низкоуровневые возможности — IR ближе к машинному коду, что позволяет оптимизировать даже «неочевидные» случаи (например, замену деления на сдвиги).   
Пример: На C компилятору сложно доказать, что цикл for (int i=0; i<10; i++) всегда выполнится 10 раз, а в IR это сразу видно в CFG и SSA-форме.
